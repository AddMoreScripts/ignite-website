<!--
▄▄▄       ██▓███   ▄▄▄       ▄████▄   ██░ ██ ▓█████     ██▓  ▄████  ███▄    █  ██▓▄▄▄█████▓▓█████
▒████▄    ▓██░  ██▒▒████▄    ▒██▀ ▀█  ▓██░ ██▒▓█   ▀    ▓██▒ ██▒ ▀█▒ ██ ▀█   █ ▓██▒▓  ██▒ ▓▒▓█   ▀
▒██  ▀█▄  ▓██░ ██▓▒▒██  ▀█▄  ▒▓█    ▄ ▒██▀▀██░▒███      ▒██▒▒██░▄▄▄░▓██  ▀█ ██▒▒██▒▒ ▓██░ ▒░▒███
░██▄▄▄▄██ ▒██▄█▓▒ ▒░██▄▄▄▄██ ▒▓▓▄ ▄██▒░▓█ ░██ ▒▓█  ▄    ░██░░▓█  ██▓▓██▒  ▐▌██▒░██░░ ▓██▓ ░ ▒▓█  ▄
▓█   ▓██▒▒██▒ ░  ░ ▓█   ▓██▒▒ ▓███▀ ░░▓█▒░██▓░▒████▒   ░██░░▒▓███▀▒▒██░   ▓██░░██░  ▒██▒ ░ ░▒████▒
▒▒   ▓▒█░▒▓▒░ ░  ░ ▒▒   ▓▒█░░ ░▒ ▒  ░ ▒ ░░▒░▒░░ ▒░ ░   ░▓   ░▒   ▒ ░ ▒░   ▒ ▒ ░▓    ▒ ░░   ░░ ▒░ ░
 ▒   ▒▒ ░░▒ ░       ▒   ▒▒ ░  ░  ▒    ▒ ░▒░ ░ ░ ░  ░    ▒ ░  ░   ░ ░ ░░   ░ ▒░ ▒ ░    ░     ░ ░  ░
 ░   ▒   ░░         ░   ▒   ░         ░  ░░ ░   ░       ▒ ░░ ░   ░    ░   ░ ░  ▒ ░  ░         ░
     ░  ░               ░  ░░ ░       ░  ░  ░   ░  ░    ░        ░          ░  ░              ░  ░
-->

<!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->

<!DOCTYPE html>
<html>
<head>
    <link rel="canonical" href="https://ignite.apache.org/collocatedprocessing.html" />
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Collocated Processing - Apache Ignite</title>
    <link media="all" rel="stylesheet" href="/css/all.css?v=1513970391">
    <link href="https://netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.css" rel="stylesheet">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,300,300italic,400italic,600,600italic,700,700italic,800,800italic' rel='stylesheet' type='text/css'>

    <!--#include virtual="/includes/sh.html" -->
</head>
<body>
<div id="wrapper">
    <!--#include virtual="/includes/header.html" -->

    <main id="main" role="main" class="container">
        <section id="memory-centric" class="page-section">
            <h1 class="first">What is Collocated Processing?</h1>
            <div class="col-sm-12 col-md-12 col-xs-12" style="padding:0 0 20px 0;">
                <div class="col-sm-6 col-md-6 col-xs-12" style="padding-left:0; padding-right:0">
                    <p>
                        The disk-centric systems, like RDBMS or NoSQL, generally utilize the classic client-server
                        approach, where the data is brought from the server to the client side where it gets processed
                        and then is usually discarded. This approach does not scale well as moving the data over the
                        network is the most expensive operation in a distributed system.
                    </p>
                    <p>
                        A much more scalable approach is <code>collocated</code> processing that reverses the flow by bringing
                        the computations to the servers where the data actually resides. This approach allows you to
                        execute advanced logic or distributed SQL with JOINs exactly where the data is stored avoiding
                        expensive serialization and network trips.
                    </p>
                </div>
                <div class="col-sm-6 col-md-6 col-xs-12" style="padding-right:0">
                    <img class="img-responsive" src="/images/collocated_processing.png" width="440px" style="float: right; margin-top: -25px;"/>
                </div>
            </div>

            <div class="page-heading">Usage Example</div>
            <p>
                Let's assume that a blizzard is approaching New York. As a telecommunication company, you have to
                send a warning text message to 8 million New Yorkers.
                With the client-server approach the company has to move all <nobr>8 million (!)</nobr> records
                from the database to the client text messaging application, which does not scale.
            </p>
            <p>
                A much more efficient approach would be to send the text-messaging logic to the cluster node responsible
                for storing the New York residents. This approach moves only 1 computation instead of 8 million records
                across the network, and performs a lot better.
            </p>

            <p>
                Here is an example of how this logic might look like:
            </p>
            <!--<ul id="compute-example" class="nav nav-tabs">-->
                <!--<li  class="active"><a href="#compute-task" aria-controls="profile" data-toggle="tab">Message Broadcasting Logic</a></li>-->
            <!--</ul>-->

            <div class="tab-content">

                <div class="tab-pane active" id="compute-task">
                        <pre class="brush:java">

Ignite ignite = ...

// NewYork ID.
long newYorkId = 2;

// Sending the logic to a cluster node that stores NewYork and all its inhabitants.
ignite.compute().affinityRun("City", newYorkId, new IgniteRunnable() {

  @IgniteInstanceResource
  Ignite ignite;

  @Override
  public void run() {
    // Getting an access to Persons cache.
    IgniteCache&#60;BinaryObject, BinaryObject&#62; people = ignite.cache("Person").withKeepBinary();


    ScanQuery&#60;BinaryObject, BinaryObject&#62; query = new ScanQuery &#60;BinaryObject, BinaryObject&#62;();

    try (QueryCursor&#60;Cache.Entry&#60;BinaryObject, BinaryObject&#62;&#62; cursor = people.query(query)) {
      // Iteration over the local cluster node data using the scan query.
      for (Cache.Entry&#60;BinaryObject, BinaryObject&#62; entry : cursor) {
        BinaryObject personKey = entry.getKey();

        // Picking NewYorker's only.
        if (personKey.&#60;Long&#62;field("CITY_ID") == newYorkId) {
            person = entry.getValue();

            // Sending the warning message to the person.
        }
      }
    }
  }
}

                        </pre>
                </div>
            </div>
            <p>
                Check more <a href="https://apacheignite.readme.io/docs/affinity-collocation" target="_blank">here</a>.
            </p>
        </section>
    </main>

    <!--#include virtual="/includes/footer.html" -->
</div>
<!--#include virtual="/includes/scripts.html" -->
</body>
</html>
