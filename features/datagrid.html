<!--
 ▄▄▄       ██▓███   ▄▄▄       ▄████▄   ██░ ██ ▓█████     ██▓  ▄████  ███▄    █  ██▓▄▄▄█████▓▓█████
▒████▄    ▓██░  ██▒▒████▄    ▒██▀ ▀█  ▓██░ ██▒▓█   ▀    ▓██▒ ██▒ ▀█▒ ██ ▀█   █ ▓██▒▓  ██▒ ▓▒▓█   ▀
▒██  ▀█▄  ▓██░ ██▓▒▒██  ▀█▄  ▒▓█    ▄ ▒██▀▀██░▒███      ▒██▒▒██░▄▄▄░▓██  ▀█ ██▒▒██▒▒ ▓██░ ▒░▒███
░██▄▄▄▄██ ▒██▄█▓▒ ▒░██▄▄▄▄██ ▒▓▓▄ ▄██▒░▓█ ░██ ▒▓█  ▄    ░██░░▓█  ██▓▓██▒  ▐▌██▒░██░░ ▓██▓ ░ ▒▓█  ▄
 ▓█   ▓██▒▒██▒ ░  ░ ▓█   ▓██▒▒ ▓███▀ ░░▓█▒░██▓░▒████▒   ░██░░▒▓███▀▒▒██░   ▓██░░██░  ▒██▒ ░ ░▒████▒
 ▒▒   ▓▒█░▒▓▒░ ░  ░ ▒▒   ▓▒█░░ ░▒ ▒  ░ ▒ ░░▒░▒░░ ▒░ ░   ░▓   ░▒   ▒ ░ ▒░   ▒ ▒ ░▓    ▒ ░░   ░░ ▒░ ░
  ▒   ▒▒ ░░▒ ░       ▒   ▒▒ ░  ░  ▒    ▒ ░▒░ ░ ░ ░  ░    ▒ ░  ░   ░ ░ ░░   ░ ▒░ ▒ ░    ░     ░ ░  ░
  ░   ▒   ░░         ░   ▒   ░         ░  ░░ ░   ░       ▒ ░░ ░   ░    ░   ░ ░  ▒ ░  ░         ░
      ░  ░               ░  ░░ ░       ░  ░  ░   ░  ░    ░        ░          ░  ░              ░  ░
-->

<!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Apache Ignite - In-Memory Data Grid</title>
    <link media="all" rel="stylesheet" href="/css/all.css">
    <link href="https://netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.css" rel="stylesheet">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,300,300italic,400italic,600,600italic,700,700italic,800,800italic' rel='stylesheet' type='text/css'>

    <!--#include virtual="/includes/sh.html" -->
</head>
<body>
<div id="wrapper">
    <!--#include virtual="/includes/header.html" -->

    <main id="main" role="main" class="container">
        <section id="datagrid" class="page-section">
            <table class="twosides">
                <tr>
                    <td>
                        <h2 class="first">Distributed In-Memory Data Grid</h2>
                        <p>
                            Ignite in-memory data grid has been built from the ground up with a notion of horizontal scale and
                            ability to add nodes on demand in real-time; it has been designed to linearly scale to hundreds of
                            nodes with strong semantics for data locality and affinity data routing to reduce redundant data noise.
                        </p>
                        <p>
                            Ignite data grid is lightning fast and is one of the fastest implementations of transactional or
                            atomic data in a cluster today. We know it because we constantly benchmark it ourselves.
                        </p>
                    </td>
                    <td>
                        <img class="first" src="/images/in_memory_data.png" width="400px"/>
                    </td>
                </tr>
            </table>
            <div class="videos">
                <div class="page-heading">Videos:</div>
                <ul>
                    <li>
                        <i class="fa fa-lg fa-play-circle-o"></i>
                        <span class="video-title">
                            <a target="youtube" href="https://www.youtube.com/watch?v=eZUujozYt-g">Distributed SQL Queries</a>
                        </span>
                        <span class="video-duration">03:27</span>
                    </li>
                    <li>
                        <i class="fa fa-lg fa-play-circle-o"></i>
                        <span class="video-title">
                            <a target="youtube" href="https://www.youtube.com/watch?v=pFbDWpOiMOU">Getting Started with Data Grid</a>
                        </span>
                        <span class="video-duration">03:49</span>
                    </li>
                </ul>
            </div>
            <div class="code-examples">
                <div class="page-heading">Examples:</div>
                <!-- Nav tabs -->
                <ul id="datagrid-examples" class="nav nav-tabs">
                    <li class="active"><a href="#datagrid-example-basic" role="tab" data-toggle="tab">Put and Get</a></li>
                    <li><a href="#datagrid-example-transactions" role="tab" data-toggle="tab">Transactions</a></li>
                    <li><a href="#datagrid-example-locks" role="tab" data-toggle="tab">Locks</a></li>
                    <li><a href="#datagrid-example-sqlquery" role="tab" data-toggle="tab">SQL Query</a></li>
                    <li><a href="#datagrid-example-sqljoin" role="tab" data-toggle="tab">SQL Join</a></li>
                    <li><a href="#datagrid-example-sqlaggregation" role="tab" data-toggle="tab">SQL Aggregation</a></li>
                </ul>

                <!-- Tab panes -->
                <div class="tab-content">
                    <div role="tabpanel" class="tab-pane active" id="datagrid-example-basic">
                        <pre class="brush:java">
                            Ignite ignite = Ignition.ignite();

                             // Get an instance of named cache.
                            final IgniteCache&lt;Integer, String&gt; cache = ignite.cache("cacheName");

                            // Store keys in cache.
                            for (int i = 0; i < 10; i++)
                                cache.put(i, Integer.toString(i));

                            // Retrieve values from cache.
                            for (int i = 0; i < 10; i++)
                                System.out.println("Got [key=" + i + ", val=" + cache.get(i) + ']');

                            // Remove objects from cache.
                            for (int i = 0; i < 10; i++)
                                cache.remove(i);

                            // Atomic put-if-absent.
                            cache.putIfAbsent(1, "1");

                            // Atomic replace.
                            cache.replace(1, "1", "2");
                        </pre>
                    </div>
                    <div role="tabpanel" class="tab-pane" id="datagrid-example-transactions">
                        <pre class="brush:java">
                            Ignite ignite = Ignition.ignite();

                            // Clone every object we get from cache, so we can freely update it.
                            IgniteCache&lt;Integer, Account&gt; cache = ignite.cache("cacheName");

                            try (IgniteTx tx = Ignition.ignite().transactions().txStart()) {
                                Account acct = cache.get(acctId);

                                assert acct != null;

                                // Deposit $20 into account.
                                acct.setBalance(acct.getBalance() + 20);

                                // Store updated account in cache.
                                cache.put(acctId, acct);

                                tx.commit();
                            }
                        </pre>
                    </div>
                    <div role="tabpanel" class="tab-pane" id="datagrid-example-locks">
                        <pre class="brush:java">
                            Ignite ignite = Ignition.ignite();

                             // Get an instance of named cache.
                            final GridCache&lt;String, Integer&gt; cache = ignite.cache("cacheName");

                            // Lock cache key "Hello".
                            Lock lock = cache.lock("Hello");

                            lock.lock();

                            try {
                                cache.put("Hello", 11);
                                cache.put("World", 22);
                            }
                            finally {
                                lock.unlock();
                            }
                        </pre>
                    </div>
                    <div role="tabpanel" class="tab-pane" id="datagrid-example-sqlquery">
                        <pre class="brush:java">
                            IgniteCache&lt;Long, Person&gt; cache = ignite.cache("mycache");

                            SqlFieldsQuery sql = new SqlFieldsQuery(
                              "select concat(firstName, ' ', lastName) from Person");

                            // Select concatinated first and last name for all persons.
                            try (QueryCursor&lt;List&lt;?&gt;&gt; cursor = cache.query(sql)) {
                              for (List&lt;?&gt; row : cursor)
                                System.out.println("Full name: " + row.get(0));
                            }
                        </pre>
                    </div>
                    <div role="tabpanel" class="tab-pane" id="datagrid-example-sqljoin">
                        <pre class="brush:java">
                            IgniteCache&lt;Long, Person&gt; personCache = ignite.cache("personCache");

                            // Select with join between Person and Organization to
                            // get the names of all the employees of a specific organization.
                            SqlFieldsQuery sql = new SqlFieldsQuery(
                                "select p.name  "
                                    + "from Person p, \"orgCache\".Organization where "
                                    + "Person.orgId = Organization.id "
                                    + "and Organization.name = ?");

                            // Execute the query and obtain the query result cursor.
                            try (QueryCursor&lt;List&lt;?&gt;&gt; cursor =  personCache.query(sql.setArgs("Ignite"))) {
                                for (List&lt;?&gt; row : cursor)
                                    System.out.println("Person name=" + row);
                            }
                        </pre>
                    </div>
                    <div role="tabpanel" class="tab-pane" id="datagrid-example-sqlaggregation">
                        <pre class="brush:java">
                            IgniteCache&lt;Long, Person&gt; personCache = ignite.cache("personCache");

                            // Select average age of people working within different departments.
                            SqlFieldsQuery sql = new SqlFieldsQuery(
                                "select avg(p.age) as avg_age, d.name as dpmt_name, o.name as org_name "
                                    + "from Person p, \"depCache\".Department d, \"orgCache\".Organization o "
                                    + "where p.depid = d.id and d.orgid = o.id "
                                    + "group by d.name, o.name "
                                    + "order by avg_age";

                            // Execute the query and obtain the query result cursor.
                            try (QueryCursor&lt;List&lt;?&gt;&gt; cursor =  personCache.query(sql.setArgs("Ignite"))) {
                                for (List&lt;?&gt; row : cursor)
                                    System.out.println("Person name=" + row);
                            }
                        </pre>
                    </div>
                </div>
            </div>
        </section>
        <section id="key-features" class="page-section">
            <h2>Data Grid Features</h2>
            <table class="formatted">
                <thead>
                    <tr>
                        <th width="35%" class="left">Feature</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td class="left">JCache (JSR 107)</td>
                        <td>
                            <p>
                                Ignite data grid is a 100% compliant implementation of <span style="white-space: nowrap">JCache (JSR 107)</span> specification.
                                JCache provides a very simple to use, but yet very powerful API for data caching.
                            </p>
                            <p>
                                Some of the JCache API features include:
                                <ul class="page-list">
                                    <li>Basic Cache Operations</li>
                                    <li>ConcurrentMap APIs</li>
                                    <li>Collocated Processing (EntryProcessor)</li>
                                    <li>Events and Metrics</li>
                                    <li>Pluggable Persistence</li>
                                </ul>
                            </p>
                            <div class="page-links">
                                <a href="http://apacheignite.readme.io/docs/jcache" target="docs">Docs for this Feature <i class="fa fa-angle-double-right"></i></a>
                            </div>
                        </td>
                    </tr>
                    <tr>
                        <td class="left">Partitioned & Replicated Caches</td>
                        <td>
                            <p>
                                Depending on configuration, Ignite can either <i>partition</i> or <i>replicate</i>
                                data in memory. Unlike REPLICATED mode, where data is fully replicated across
                                all nodes in the cluster, in PARTITIONED mode Ignite will equally split the data
                                across multiple cluster nodes, allowing for caching TBs of data in memory.
                            </p>
                            <p>
                                Ignite also allows to configure multiple <b>backup copies</b> to gurantee data resiliency
                                in case of failures.
                            </p>
                            <p>
                                Regardless of which caching mode is used, Ignite guarantees data consistency
                                across all cluster members, regardless of various failure conditions.
                            </p>
                            <div class="page-links">
                                <a href="http://apacheignite.readme.io/docs/cache-modes" target="docs">Docs for this Feature <i class="fa fa-angle-double-right"></i></a>
                            </div>
                        </td>
                    </tr>
                    <tr>
                        <td class="left">Client-side Near Caches</td>
                        <td>
                            <p>
                                Whenever the data is accessed from remote clients, Ignite also supports client-side
                                NEAR caching. In <i>transactional</i> mode, the data stored in NEAR caches is also
                                transactional and is either automatically updated or invalidated in consistent fashion
                                update transaction commit.
                            </p>
                            <p>
                                Regardless of which caching mode is used, Ignite guarantees data consistency
                                across all cluster members, regardless of various failure conditions.
                            </p>
                            <div class="page-links">
                                <a href="http://apacheignite.readme.io/docs/near-caches" target="docs">Docs for this Feature <i class="fa fa-angle-double-right"></i></a>
                            </div>
                        </td>
                    </tr>
                    <tr>
                        <td class="left">ACID Transactions</td>
                        <td>
                            <p>
                                Ignite supports 2 modes for cache operation, <i>transactional</i> and <i>atomic</i>.
                                In <i>transactional</i> mode you are able to group multiple cache operations in a
                                transaction, while <i>atomic</i> mode supports multiple atomic operations, one at a time.
                                <i>Atomic</i> mode is more light-weight and generally has better performance over transactional
                                caches.
                            </p>
                            <p>
                                In <i>transactional</i> mode Ignite supports OPTIMISTIC and PESSIMISTIC transactions and
                                utilizes 2PC protocol with many <i>one-phase-commit</i> optimizations whenever applicable.
                            </p>
                            <div class="page-links">
                                <a href="http://apacheignite.readme.io/docs/transactions" target="docs">Docs for this Feature <i class="fa fa-angle-double-right"></i></a>
                            </div>
                        </td>
                    </tr>
                    <tr>
                        <td class="left">Queries & Distributed Joins</td>
                        <td>
                            <p>
                                Ignite supports a very elegant query API with support for:
                                <ul class="page-list">
                                    <li>Predicate-based Scan Queries</li>
                                    <li>SQL Queries (ANSI 99)</li>
                                    <li>Text Queries</li>
                                </ul>
                            </p>
                            <p>
                                For SQL and TEXT queries ignites supports in-memory indexing, so all the data lookups are extremely fast.
                                If you are caching your data in off-heap memory, then query indexes will also be cached in off-heap memory as well.
                            </p>
                            <p>
                                Ignite also allows users to implement their own custom indexing using pluggable
                                <i>IndexingSpi</i>.
                            </p>
                            <div class="page-links">
                                <a href="http://apacheignite.readme.io/docs/cache-queries" target="docs">Docs for this Feature <i class="fa fa-angle-double-right"></i></a>
                            </div>
                        </td>
                    </tr>
                    <tr>
                        <td class="left">Continuous Queries</td>
                        <td>
                            <p>
                                Continuous queries are useful for cases when you want to execute a query and then
                                continue to get notified about the data changes that fall into your query filter.
                            </p>
                            <div class="page-links">
                                <a href="http://apacheignite.readme.io/docs/continuous-queries" target="docs">Docs for this Feature <i class="fa fa-angle-double-right"></i></a>
                            </div>
                        </td>
                    </tr>
                    <tr>
                        <td class="left">Off-Heap and On-Heap Memory</td>
                        <td>
                            <p>
                                Ignite supports 2 modes for caching data in-memory:
                                <span style="white-space: nowrap"><i>off-heap</i></span> and
                                <span style="white-space: nowrap"><i>on-heap</i></span>.
                                Off-Heap memory allows your cache to overcome lengthy JVM Garbage Collection (GC) pauses
                                when working with large heap sizes by caching data outside of main Java Heap space,
                                but still in RAM.
                            </p>
                            <p>
                                Whenever off-heap memory is configured, Ignite will also store query indexes off-heap
                                as well. This means that indexes will not take any portion of on-heap memory.
                            </p>
                            <div class="page-links">
                                <a href="http://apacheignite.readme.io/docs/off-heap-memory" target="docs">Docs for this Feature <i class="fa fa-angle-double-right"></i></a>
                            </div>
                        </td>
                    </tr>
                    <tr>
                        <td class="left">Tiered Memory</td>
                        <td>
                            <p>
                                As data gets colder (not accessed) Ignite will optaionally migrate it
                                from On-Heap to Off-Heap and from Off-Heap to Swap (disk) storage.
                            </p>
                            <p>
                                Whenever some data is accessed, it will immediately be propagated to the top tier
                                pushing some other colder data down the next memory tier.
                            </p>
                            <div class="page-links">
                                <a href="http://apacheignite.readme.io/docs/off-heap-memory" target="docs">Docs for this Feature <i class="fa fa-angle-double-right"></i></a>
                            </div>
                        </td>
                    </tr>
                    <tr>
                        <td class="left">JDBC Driver</td>
                        <td>
                            <p>
                                Ignite is shipped with JDBC driver that allows you to retrieve distributed data from
                                cache using standard SQL queries and JDBC API.
                            </p>
                            <p>
                                JDBC driver allows users to connect to Ignite using any standard SQL tool and start
                                executing SQL queries against the in-memory data stored in Ignite caches.
                            </p>
                            <div class="page-links">
                                <a href="http://apacheignite.readme.io/docs/jdbc-driver" target="docs">Docs for this Feature <i class="fa fa-angle-double-right"></i></a>
                            </div>
                        </td>
                    </tr>
                    <tr>
                        <td class="left">Web Session Clustering</td>
                        <td>
                            <p>
                                Ignite In-Memory Data Fabric is capable of caching web sessions of all Java Servlet
                                containers that follow Java Servlet 3.0 Specification, including Apache Tomcat,
                                Eclipse Jetty, Oracle WebLogic, and others.
                            </p>
                            <p>
                                Web sessions caching becomes useful when running a cluster of app servers to improve
                                performance and scalability of the servlet container.
                            </p>
                            <div class="page-links">
                                <a href="http://apacheignite.readme.io/docs/web-session-clustering" target="docs">Docs for this Feature <i class="fa fa-angle-double-right"></i></a>
                            </div>
                        </td>
                    </tr>
                    <tr>
                        <td class="left">Hibernate L2 Caching</td>
                        <td>
                            <p>
                                Ignite In-Memory Data Fabric can be used as Hibernate Second-Level cache (or L2 cache),
                                which can significantly speed-up the persistence layer of your application.
                            </p>
                            <div class="page-links">
                                <a href="http://apacheignite.readme.io/docs/hibernate-l2-cache" target="docs">Docs for this Feature <i class="fa fa-angle-double-right"></i></a>
                            </div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>
    </main>

    <!--#include virtual="/includes/footer.html" -->
</div>
<!--#include virtual="/includes/scripts.html" -->
</body>
</html>
